using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace CSharpProblemSolving
{
	public class MakePalindrome
	{
		public string[] constructMinimal(string card)
		{
			Dictionary<char, int> list = new Dictionary<char, int>();
			int totalNum = card.Length;
			List<string> returnList = new List<string>();
			foreach (char c in card)
			{
				if (!list.ContainsKey(c))
				{
					list.Add(c, 1);
				}
				else
				{
					var val = list[c];
					list[c] = val + 1;
				}
			}

			// At least one even
			if (list.Count(_ => _.Value % 2 == 0) == 0)
			{
				// No even
				foreach (KeyValuePair<char, int> keyValuePair in list)
				{
					StringBuilder builder = new StringBuilder();
					for (int i = 0; i < keyValuePair.Value; i++)
					{
						builder.Append(keyValuePair.Key);
					}
					returnList.Add(builder.ToString());
				}
			}
			var max = list.Values.Max();
			var maxDict = list.Where(_ => _.Value == max && max % 2 != 0).ToList()[0];
			var maxKey = maxDict.Key;
			StringBuilder builder1 = new StringBuilder();
			for (int i = 0; i < maxDict.Value; i++)
			{
				builder1.Append(maxKey);
			}
			list.Remove(maxKey);
			foreach (var pair in list)
			{
				if (pair.Value % 2 == 0)
				{
					for (int i = 0; i < pair.Value / 2; i++)
					{
						builder1.Append(pair.Key);
						builder1.Insert(0, pair.Key);
					}
				}
			}

			return returnList.ToArray();
		}

		// BEGIN KAWIGIEDIT TESTING
		// Generated by KawigiEdit-pf 2.3.0
		#region Testing code generated by KawigiEdit
		[STAThread]
		private static Boolean KawigiEdit_RunTest(int testNum, string p0, Boolean hasAnswer, string[] p1) {
			Console.Write("Test " + testNum + ": [" + "\"" + p0 + "\"");
			Console.WriteLine("]");
			MakePalindrome obj;
			string[] answer;
			obj = new MakePalindrome();
			DateTime startTime = DateTime.Now;
			answer = obj.constructMinimal(p0);
			DateTime endTime = DateTime.Now;
			Boolean res;
			res = true;
			Console.WriteLine("Time: " + (endTime - startTime).TotalSeconds + " seconds");
			if (hasAnswer) {
				Console.WriteLine("Desired answer:");
				Console.Write("\t" + "{");
				for (int i = 0; p1.Length > i; ++i) {
					if (i > 0) {
						Console.Write(",");
					}
					Console.Write("\"" + p1[i] + "\"");
				}
				Console.WriteLine("}");
			}
			Console.WriteLine("Your answer:");
			Console.Write("\t" + "{");
			for (int i = 0; answer.Length > i; ++i) {
				if (i > 0) {
					Console.Write(",");
				}
				Console.Write("\"" + answer[i] + "\"");
			}
			Console.WriteLine("}");
			if (hasAnswer) {
				if (answer.Length != p1.Length) {
					res = false;
				} else {
					for (int i = 0; answer.Length > i; ++i) {
						if (answer[i] != p1[i]) {
							res = false;
						}
					}
				}
			}
			if (!res) {
				Console.WriteLine("DOESN'T MATCH!!!!");
			} else if ((endTime - startTime).TotalSeconds >= 2) {
				Console.WriteLine("FAIL the timeout");
				res = false;
			} else if (hasAnswer) {
				Console.WriteLine("Match :-)");
			} else {
				Console.WriteLine("OK, but is it right?");
			}
			Console.WriteLine("");
			return res;
		}
		public static void __Main(string[] args) {
			Boolean all_right;
			Boolean disabled;
			Boolean tests_disabled;
			all_right = true;
			tests_disabled = false;
		
			string p0;
			string[] p1;
		
			// ----- test 0 -----
			disabled = false;
			p0 = "abbaa";
			p1 = new string[]{"ababa"};
			all_right = (disabled || KawigiEdit_RunTest(0, p0, true, p1) ) && all_right;
			tests_disabled = tests_disabled || disabled;
			// ------------------
		
			// ----- test 1 -----
			disabled = false;
			p0 = "abc";
			p1 = new string[]{"a","b","c"};
			all_right = (disabled || KawigiEdit_RunTest(1, p0, true, p1) ) && all_right;
			tests_disabled = tests_disabled || disabled;
			// ------------------
		
			// ----- test 2 -----
			disabled = false;
			p0 = "aaabbbccc";
			p1 = new string[]{"aba","bcb","cac"};
			all_right = (disabled || KawigiEdit_RunTest(2, p0, true, p1) ) && all_right;
			tests_disabled = tests_disabled || disabled;
			// ------------------
		
			// ----- test 3 -----
			disabled = false;
			p0 = "topcoder";
			p1 = new string[]{"oco","d","e","p","r","t"};
			all_right = (disabled || KawigiEdit_RunTest(3, p0, true, p1) ) && all_right;
			tests_disabled = tests_disabled || disabled;
			// ------------------
		
			// ----- test 4 -----
			disabled = false;
			p0 = "z";
			p1 = new string[]{"z"};
			all_right = (disabled || KawigiEdit_RunTest(4, p0, true, p1) ) && all_right;
			tests_disabled = tests_disabled || disabled;
			// ------------------
		
			if (all_right) {
				if (tests_disabled) {
					Console.WriteLine("You're a stud (but some test cases were disabled)!");
				} else {
					Console.WriteLine("You're a stud (at least on given cases)!");
				}
			} else {
				Console.WriteLine("Some of the test cases had errors.");
			}
		}
		#endregion
		// PROBLEM STATEMENT
		// You have some cards.
		// Each card contains a single lowercase letter.
		// You are given these letters as the characters of the string card.
		// 
		// 
		// A palindrome is a string that reads the same forwards and backwards.
		// Examples of palindromes: "eve", "abba", "aaaaaa", and "racecar".
		// 
		// 
		// Use the cards you have to spell some palindromes. In particular:
		// 
		// Each card must be used in exactly one of the palindromes.
		// The total number of palindromes must be as small as possible.
		// 
		// 
		// Return a string[] containing the palindromes you built.
		// (Each element of the return value should be one of the palindromes.)
		// 
		// 
		// A solution always exists.
		// If there are multiple optimal solutions, you may choose and output any one of them.
		// 
		// DEFINITION
		// Class:MakePalindrome
		// Method:constructMinimal
		// Parameters:string
		// Returns:string[]
		// Method signature:string[] constructMinimal(string card)
		// 
		// 
		// CONSTRAINTS
		// -card will contain between 1 and 1,000 characters, inclusive.
		// -Each character in card will be a lowercase English letter ('a'-'z').
		// 
		// 
		// EXAMPLES
		// 
		// 0)
		// "abbaa"
		// 
		// Returns: {"ababa" }
		// 
		// We can rearrange all letters into a single palindrome. There are two ways to do so: one is "ababa", the other is "baaab".
		// 
		// 1)
		// "abc"
		// 
		// Returns: {"a", "b", "c" }
		// 
		// This time the only solution is to build three palindromes, each consisting of a single letter. Note that you may return the three strings in any order.
		// 
		// 2)
		// "aaabbbccc"
		// 
		// Returns: {"aba", "bcb", "cac" }
		// 
		// There are other solutions like {"aaa", "bbb", "ccc"}
		// 
		// 3)
		// "topcoder"
		// 
		// Returns: {"oco", "d", "e", "p", "r", "t" }
		// 
		// 
		// 
		// 4)
		// "z"
		// 
		// Returns: {"z" }
		// 
		// 
		// 
		// END KAWIGIEDIT TESTING
	}
}

//Powered by KawigiEdit-pf 2.3.0!
